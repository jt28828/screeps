module.exports=function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);class MemoryManager{static initialise(){null==Memory.myMemory&&(Memory.myMemory={roomIds:[]})}static clean(){this.removeDeadCreeps()}static removeDeadCreeps(){if(null==Memory.creeps)return;const creepIds=Object.keys(Memory.creeps);for(const creepId of creepIds){null==Game.creeps[creepId]&&this.deleteCreep(creepId)}}static deleteCreep(creepId){delete Memory.creeps[creepId]}}const buildingFlags=[STRUCTURE_EXTENSION,STRUCTURE_RAMPART,STRUCTURE_ROAD,STRUCTURE_SPAWN,STRUCTURE_LINK,STRUCTURE_WALL,STRUCTURE_STORAGE,STRUCTURE_TOWER,STRUCTURE_OBSERVER,STRUCTURE_POWER_SPAWN,STRUCTURE_EXTRACTOR,STRUCTURE_LAB,STRUCTURE_TERMINAL,STRUCTURE_CONTAINER,STRUCTURE_NUKER],groupBuildingFlags=["extension-group","road-group","tower-group"];class town_planner_TownPlanner{constructor(room,flags){this.room=room,this.singleBuildFlags=flags.filter(flag=>buildingFlags.includes(flag.name)),this.groupBuildFlags=flags.filter(flag=>groupBuildingFlags.some(groupFlagOptions=>flag.name.includes(groupFlagOptions)))}control(){this.placeSingleBuildsites(),this.placeGroupBuildsites()}placeSingleBuildsites(){for(const flag of this.singleBuildFlags)0===flag.pos.lookFor(LOOK_CONSTRUCTION_SITES).length&&(flag.pos.createConstructionSite(flag.name),flag.remove())}placeGroupBuildsites(){for(const flag of this.groupBuildFlags){const splitFlagName=flag.name.split("-group-"),buildStructure=splitFlagName[0];let buildSize=3;if(""!=splitFlagName[1]&&null!=splitFlagName[1])try{buildSize=parseInt(splitFlagName[1])}catch(e){console.error("Non-number value passed through as parameter for group build flag. Using the default value of 3")}const buildSites=this.getGroupBuildsites(flag,buildSize);for(const futureSite of buildSites)futureSite.createConstructionSite(buildStructure);flag.remove()}}getGroupBuildsites(flag,buildSize){let positions=[];return positions=flag.name.includes("-group")?this.getEmptyBlocksAround(flag.pos,buildSize):[flag.pos],positions}getEmptyBlocksAround(position,squareSize){const topLeftDifference=Math.floor(squareSize/2),originalX=position.x-topLeftDifference,currentPos={x:originalX,y:position.y-topLeftDifference},positions=[];let placeEven=!0;for(let i=0;i<squareSize;i++){for(let j=0;j<squareSize;j++){if(placeEven&&j%2==0||!placeEven&&j%2!=0){const thisPos=this.room.getPositionAt(currentPos.x,currentPos.y);if(null!=thisPos){thisPos.lookFor(LOOK_TERRAIN).includes("wall")||positions.push(thisPos)}}++currentPos.x}++currentPos.y,currentPos.x=originalX,placeEven=!placeEven}return positions}}const allyUsernames=["Smudgemuffin","mooseyman"];class room_memory_manager_RoomMemoryManager{constructor(room,roomFlags){this.room=room,this.roomFlags=roomFlags,this.roomStatus=this.room.memory.roomStatus}get damagedStructures(){return void 0===this._damagedStructures&&(this._damagedStructures=this.room.memory.damagedStructureIds.map(id=>Game.getObjectById(id)).filter(entity=>null!=entity)),this._damagedStructures}get enemies(){return void 0===this._enemies&&(this._enemies=this.room.memory.enemyIds.map(id=>Game.getObjectById(id)).filter(entity=>null!=entity)),this._enemies}get structures(){return void 0===this._allStructures&&(this._allStructures=this.room.memory.structureIds.map(id=>Game.getObjectById(id)).filter(entity=>null!=entity)),this._allStructures}get myStructures(){return void 0===this._myStructures&&(this._myStructures=this.room.memory.myStructureIds.map(id=>Game.getObjectById(id)).filter(entity=>null!=entity)),this._myStructures}get constructionSites(){return void 0===this._constructionSites&&(this._constructionSites=this.room.memory.constructionSiteIds.map(id=>Game.getObjectById(id)).filter(entity=>null!=entity)),this._constructionSites}get myCreeps(){return void 0===this._myCreeps&&(this._myCreeps=this.room.find(FIND_MY_CREEPS)),this._myCreeps}get droppedEnergy(){return void 0===this._droppedEnergy&&(this._droppedEnergy=this.room.find(FIND_DROPPED_RESOURCES).filter(dropPoint=>dropPoint.resourceType===RESOURCE_ENERGY&&dropPoint.amount>100)),this._droppedEnergy}calculateNonVolatileRoomState(){var _a;const allStructures=this.room.find(FIND_STRUCTURES),myStructures=this.room.find(FIND_MY_STRUCTURES),constructionSites=this.room.find(FIND_CONSTRUCTION_SITES),droppedEnergy=this.room.find(FIND_DROPPED_RESOURCES).filter(dropPoint=>dropPoint.resourceType===RESOURCE_ENERGY&&dropPoint.amount>150),enemies=this.room.find(FIND_HOSTILE_CREEPS).filter(creep=>-1===allyUsernames.indexOf(creep.owner.username)).sort((a,b)=>a.hits-b.hits),damagedStructures=allStructures.filter(x=>x.hits<x.hitsMax&&x.hits<1e7).sort((a,b)=>a.hits-b.hits),roomIsOwned=null===(_a=this.room.controller)||void 0===_a?void 0:_a.my;return this._damagedStructures=damagedStructures,this._enemies=enemies,this._allStructures=allStructures,this._myStructures=myStructures,this._constructionSites=constructionSites,this._droppedEnergy=droppedEnergy,this.roomStatus=roomIsOwned?1:0,this}saveStateToMemory(){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m;return this.room.memory.damagedStructureIds=null!==(_b=null===(_a=this._damagedStructures)||void 0===_a?void 0:_a.map(x=>x.id))&&void 0!==_b?_b:[],this.room.memory.enemyIds=null!==(_d=null===(_c=this._enemies)||void 0===_c?void 0:_c.map(x=>x.id))&&void 0!==_d?_d:[],this.room.memory.structureIds=null!==(_f=null===(_e=this._allStructures)||void 0===_e?void 0:_e.map(x=>x.id))&&void 0!==_f?_f:[],this.room.memory.myStructureIds=null!==(_h=null===(_g=this._myStructures)||void 0===_g?void 0:_g.map(x=>x.id))&&void 0!==_h?_h:[],this.room.memory.constructionSiteIds=null!==(_k=null===(_j=this._constructionSites)||void 0===_j?void 0:_j.map(site=>site.id))&&void 0!==_k?_k:[],this.room.memory.droppedEnergyIds=null!==(_m=null===(_l=this._droppedEnergy)||void 0===_l?void 0:_l.map(dropSite=>dropSite.id))&&void 0!==_m?_m:[],this.room.memory.roomStatus=this.roomStatus,this}calculateRoomLevel(){return this.myStructures.filter(struct=>struct.structureType===STRUCTURE_EXTENSION).length<2||this.room.energyAvailable<500?this.room.memory.currentLevel=0:this.room.memory.sourceCount<2?this.room.memory.currentLevel=1:this.room.memory.currentLevel=2,this}countRoomSources(){return this.room.memory.sourceCount=this.room.find(FIND_SOURCES).length,this}}class StorageUtils{static storeIsFull(storageEntity){return storageEntity.store.energy===storageEntity.store.getCapacity()}static storeIsEmpty(storageEntity){return 0===storageEntity.store.energy}static energyIsFull(storageEntity){return storageEntity.store.energy===storageEntity.store.getCapacity()}static energyIsEmpty(storageEntity){return 0===storageEntity.energy}}class creep_controller_CreepController{constructor(roomState,creep){this._roomState=roomState,this._creep=creep}get memory(){return this._creep.memory}get currentRoom(){return this._roomState.room}moveTo(target){const success=this._creep.moveTo(target,{visualizePathStyle:{stroke:"#257eff"},reusePath:10,ignoreCreeps:!1});return success!==OK&&success!==ERR_TIRED&&++this._creep.memory.stuckCounter>=2?(this._creep.say("I'm Stuck"),this._creep.memory.stuckCounter=0,this._creep.moveTo(target,{reusePath:0,ignoreCreeps:!1})):OK}creepHasEnergyTarget(){return void 0!==this._creep.memory.currentTaskTargetId&&(2===this.memory.currentTask||1===this.memory.currentTask)}isNextTo(position){return this._creep.pos.inRangeTo(position,1)}findClosest(list){return this._creep.pos.findClosestByPath(list)}clearTaskTarget(){delete this._creep.memory.currentTaskTargetId}clearTask(){delete this._creep.memory.currentTaskTargetId,delete this._creep.memory.currentTask}setTask(task){null===this._creep.memory.currentTask&&this.sayNewTask(task),this._creep.memory.currentTask=task}creepIsFull(){return StorageUtils.storeIsFull(this._creep)}creepIsEmpty(){return StorageUtils.storeIsEmpty(this._creep),0===this._creep.store.energy}sayNewTask(task){let sayText;switch(task){case 0:sayText="‚õè Mine";break;case 1:sayText="‚ö° Deposit";break;case 2:sayText="üîå Collect";break;case 3:sayText="üõ† Build";break;case 4:sayText="üõ† Repair";break;case 5:sayText="‚¨Ü Upgrade";break;case 6:sayText="‚ûï Spawn";break;case 7:sayText="üî´ Towers";break;case 8:sayText="üöö Storing";break;default:sayText="Unknown"}this._creep.say(sayText)}}class CreepControllerModule{constructor(creep,controller){this._creep=creep,this._controller=controller}}class miner_module_MinerModule extends CreepControllerModule{constructor(creep,controller){super(creep,controller)}mineForEnergy(){let source;if(void 0===this._creep.memory.currentTaskTargetId){const newTarget=this.getNewMiningTarget();if(null==newTarget)return 1;source=newTarget,this._creep.memory.currentTaskTargetId=source.id}else source=Game.getObjectById(this._creep.memory.currentTaskTargetId);return this._creep.harvest(source)===ERR_NOT_IN_RANGE&&this.moveToSourceOrContainer(source),0}getNewMiningTarget(){let sources=this._controller._roomState.room.find(FIND_SOURCES);if(this.creepIsMiner(this._creep)){const approvedSources=[],otherMiners=this._controller._roomState.myCreeps.filter(creep=>1===creep.memory.currentRole);for(let i=0;i<sources.length;i++)otherMiners.every(miner=>miner.memory.currentTaskTargetId!==sources[i].id)&&approvedSources.push(sources[i]);sources=approvedSources}const closestSource=this._creep.pos.findClosestByPath(sources,{});return null==closestSource&&0===this._controller._roomState.room.memory.sourceCount?(console.error("A mining creep is in a room with no sources"),this._creep.say("I have no reason to live"),Game.notify(`You have more miner creeps than sources in room: ${this._controller._roomState.room.name}`),this._creep.suicide(),null):closestSource}moveToSourceOrContainer(source){let targetPosition=source.pos;if(this.creepIsMiner(this._creep))if(void 0===this._creep.memory.containerTargetId){const allContainers=this.getRoomContainers(),closestContainer=source.pos.findInRange(allContainers,1)[0];null!=closestContainer&&(this._creep.memory.containerTargetId=closestContainer.id,targetPosition=closestContainer.pos)}else{const target=this.getTargetContainer(this._creep.memory.containerTargetId);null==target?delete this._creep.memory.containerTargetId:targetPosition=target.pos}this._controller.moveTo(targetPosition)}creepIsMiner(creep){return 1===creep.memory.currentRole}getRoomContainers(){return this._controller._roomState.structures.filter(struct=>struct.structureType===STRUCTURE_CONTAINER)}getTargetContainer(structId){return this._controller._roomState.structures.find(struct=>struct.id==structId)}}class energy_transfer_module_EnergyTransferModule extends CreepControllerModule{depositToStorage(){const storage=this.getNonFullStorage();if(void 0===storage)return this._controller.clearTask(),1;const response=this._creep.transfer(storage,RESOURCE_ENERGY);if(response===ERR_NOT_IN_RANGE)this._controller.moveTo(storage.pos);else if(response===ERR_NOT_ENOUGH_ENERGY)return this._controller.clearTask(),2;return 0}retrieveEnergy(fillingStorage=!1){let collectionTarget;if(void 0===this._creep.memory.currentTaskTargetId){const newTarget=this.getNewNonEmptyEnergyTarget(fillingStorage);if(null==newTarget)return this._controller.clearTask(),1;collectionTarget=newTarget,this._creep.memory.currentTaskTargetId=collectionTarget.id}else{const retrievedTarget=this.getContainerOrStorage(this._creep.memory.currentTaskTargetId);if(null==retrievedTarget)return this._controller.clearTaskTarget(),0;collectionTarget=retrievedTarget}const response=this._creep.withdraw(collectionTarget,RESOURCE_ENERGY);if(response===ERR_NOT_IN_RANGE)this._controller.moveTo(collectionTarget.pos);else if(response===ERR_NOT_ENOUGH_ENERGY)this._controller.clearTaskTarget();else if(response===ERR_FULL)return this._controller.clearTask(),2;return 0}pickupDroppedEnergy(){let pickupTarget;if(void 0===this._creep.memory.currentTaskTargetId){const newTarget=this.getNewDroppedEnergyTarget();if(null==newTarget)return this._controller.clearTask(),1;pickupTarget=newTarget,this._creep.memory.currentTaskTargetId=pickupTarget.id}else{const retrievedTarget=this.getDroppedEnergyReference(this._creep.memory.currentTaskTargetId);if(null==retrievedTarget)return this._controller.clearTaskTarget(),0;pickupTarget=retrievedTarget}const response=this._creep.pickup(pickupTarget);if(response===ERR_NOT_IN_RANGE)this._controller.moveTo(pickupTarget.pos);else if(response===ERR_FULL)return this._controller.clearTask(),2;return 0}getContainerOrStorage(structId){return this._controller._roomState.structures.find(struct=>struct.id===structId)}getDroppedEnergyReference(entityId){return this._controller._roomState.droppedEnergy.find(entity=>entity.id===entityId)}getNewNonEmptyEnergyTarget(fillingStorage=!1){const energyTargets=this._controller._roomState.structures.filter(struct=>{let matches;return matches=fillingStorage?struct.structureType===STRUCTURE_CONTAINER&&!StorageUtils.storeIsEmpty(struct):(struct.structureType===STRUCTURE_CONTAINER||struct.structureType===STRUCTURE_STORAGE)&&!StorageUtils.storeIsEmpty(struct),matches});let foundStructure;return foundStructure=fillingStorage?energyTargets.sort((structA,structB)=>structB.store.energy-structA.store.energy)[0]:this._creep.pos.findClosestByPath(energyTargets),foundStructure}getNonFullStorage(){let returnValue=this._controller._roomState.room.storage;return void 0!==returnValue&&StorageUtils.storeIsFull(returnValue)&&(returnValue=void 0),returnValue}getNewDroppedEnergyTarget(){return this._controller.findClosest(this._controller._roomState.droppedEnergy)}}class build_module_BuildModule extends CreepControllerModule{buildConstructionSite(){if(void 0===this._controller.memory.currentTaskTargetId)return this.getNewConstructionSite();{const constructionSite=this.getTargetConstructionSite(this._controller.memory.currentTaskTargetId);if(void 0===constructionSite)this._controller.clearTaskTarget();else{const response=this._creep.build(constructionSite);response===ERR_NOT_IN_RANGE?this._controller.moveTo(constructionSite.pos):response===ERR_NOT_ENOUGH_ENERGY&&this._controller.clearTask()}}return 0}getNewConstructionSite(){let response=0;const closestSite=this._controller.findClosest(this._controller._roomState.constructionSites);return null!=closestSite?this._controller.memory.currentTaskTargetId=closestSite.id:(this._controller.clearTask(),response=1),response}getTargetConstructionSite(siteId){return this._controller._roomState.constructionSites.find(site=>site.id===siteId)}roomHasConstructionSites(){return 0!==this._controller._roomState.constructionSites.length}}class upgrade_module_UpgradeModule extends CreepControllerModule{upgradeController(){const inGameController=this._controller.currentRoom.controller;if(void 0===inGameController)return;const response=this._creep.upgradeController(inGameController);response===ERR_NOT_IN_RANGE?this._controller.moveTo(inGameController.pos):response===ERR_NOT_ENOUGH_ENERGY&&this._controller.clearTask()}signController(){const inGameController=this._controller.currentRoom.controller;void 0!==inGameController&&this._creep.signController(inGameController,"Imagine playing a programming game with someone else's code")===ERR_NOT_IN_RANGE&&this._controller.moveTo(inGameController.pos)}isControllerSigned(){var _a,_b;return"james1652"===(null===(_b=null===(_a=this._controller.currentRoom.controller)||void 0===_a?void 0:_a.sign)||void 0===_b?void 0:_b.username)}}class energy_filling_module_EnergyFillingModule extends CreepControllerModule{fillClosest(){let target;if(void 0===this._creep.memory.currentTaskTargetId){const newTarget=this.findNonFullEnergyTargets();if(null==newTarget)return this._controller.clearTask(),1;target=newTarget,this._creep.memory.currentTaskTargetId=target.id}else if(target=this.getEnergyTarget(this._creep.memory.currentTaskTargetId),null==target)return this._controller.clearTaskTarget(),0;const response=this._creep.transfer(target,RESOURCE_ENERGY);if(response===ERR_NOT_IN_RANGE)this._controller.moveTo(target.pos);else{if(response===ERR_NOT_ENOUGH_ENERGY)return this._controller.clearTask(),2;ERR_FULL,this._controller.clearTaskTarget()}return 0}findNonFullEnergyTargets(){const energyTargets=this._controller._roomState.myStructures.filter(struct=>(struct.structureType===STRUCTURE_SPAWN||struct.structureType===STRUCTURE_EXTENSION)&&struct.energy!==struct.energyCapacity);return this._controller.findClosest(energyTargets)}getEnergyTarget(targetId){return this._controller._roomState.myStructures.find(struct=>struct.id===targetId)}}class allrounder_creep_controller_AllRounderCreepController extends creep_controller_CreepController{constructor(roomState,creep,isAdvancedLevel=!1){super(roomState,creep),this.modules={mine:new miner_module_MinerModule(creep,this),transfer:new energy_transfer_module_EnergyTransferModule(creep,this),build:new build_module_BuildModule(creep,this),upgrade:new upgrade_module_UpgradeModule(creep,this),fill:new energy_filling_module_EnergyFillingModule(creep,this)},this._isAdvancedLevel=isAdvancedLevel}control(){switch(this.memory.currentTask){case 9:this.modules.transfer.pickupDroppedEnergy();break;case 2:this.modules.transfer.retrieveEnergy();break;case 0:this.mineIfNotFull();break;case 3:this.modules.build.buildConstructionSite();break;case 6:this.modules.fill.fillClosest();break;case 5:this.modules.upgrade.upgradeController();break;default:this.getNewTaskForCreep()}}mineIfNotFull(){this.creepIsFull()?this.clearTask():this.modules.mine.mineForEnergy()}getNewTaskForCreep(){this._isAdvancedLevel?this.getNewHighLevelTaskForCreep():this.getNewLowLevelTaskForCreep()}getNewLowLevelTaskForCreep(){if(super.creepIsFull())if(this.modules.build.roomHasConstructionSites())super.setTask(3),this.modules.build.buildConstructionSite();else{0!==this.modules.fill.fillClosest()&&(super.setTask(5),this.modules.upgrade.upgradeController())}else this.pickupCollectOrMine()}getNewHighLevelTaskForCreep(){super.creepIsFull()?this.highLevelFillOrBuild():this.pickupCollectOrMine()}pickupCollectOrMine(){if(super.setTask(9),!(0===this.modules.transfer.pickupDroppedEnergy())){super.setTask(2),0===this.modules.transfer.retrieveEnergy()||(this._creep.say("Forced to Mine"),super.setTask(0),this.modules.mine.mineForEnergy())}}highLevelFillOrBuild(){if(this._roomState.room.find(FIND_FLAGS).find(flag=>flag.name.includes("priorityBuild")))this.modules.build.roomHasConstructionSites()?(super.setTask(3),this.modules.build.buildConstructionSite()):this.modules.fill.fillClosest();else{0!==this.modules.fill.fillClosest()&&(super.setTask(3),this.modules.build.buildConstructionSite())}}}class miner_creep_controller_MinerCreepController extends creep_controller_CreepController{constructor(roomState,creep){super(roomState,creep),this.modules={mine:new miner_module_MinerModule(creep,this),transfer:new energy_transfer_module_EnergyTransferModule(creep,this)}}control(){this.modules.mine.mineForEnergy()}getNewTaskForCreep(){}}class energy_maintenance_module_EnergyMaintenanceModule extends CreepControllerModule{fillTowers(){let targetTower;if(void 0===this._creep.memory.currentTaskTargetId){const newTower=this.getNewNonFullTowerTarget();if(null==newTower)return this._controller.clearTask(),1;targetTower=newTower,this._creep.memory.currentTaskTargetId=newTower.id}else{let newTower=this.getTower(this._creep.memory.currentTaskTargetId);if(null==newTower&&(this._controller.clearTaskTarget(),newTower=this.getNewNonFullTowerTarget(),null==newTower))return 1;targetTower=newTower,this._creep.memory.currentTaskTargetId=newTower.id}const response=this._creep.transfer(targetTower,RESOURCE_ENERGY);if(response===ERR_NOT_IN_RANGE)this._controller.moveTo(targetTower.pos);else if(response===ERR_FULL)this._controller.clearTaskTarget();else if(response===ERR_NOT_ENOUGH_ENERGY)return this._controller.clearTask(),2;return 0}getNewNonFullTowerTarget(){return this._controller._roomState.myStructures.filter(struct=>struct.structureType===STRUCTURE_TOWER&&!StorageUtils.energyIsFull(struct)).sort((tower1,tower2)=>tower1.store.energy-tower2.store.energy)[0]}getTower(towerId){return this._controller._roomState.myStructures.find(struct=>struct.id===towerId)}}class transporter_creep_controller_TransporterCreepController extends creep_controller_CreepController{constructor(roomState,creep){super(roomState,creep),this.modules={transfer:new energy_transfer_module_EnergyTransferModule(creep,this),filling:new energy_filling_module_EnergyFillingModule(creep,this),maintenance:new energy_maintenance_module_EnergyMaintenanceModule(creep,this)}}control(){switch(this.memory.currentTask){case 9:this.modules.transfer.pickupDroppedEnergy();break;case 2:this.modules.transfer.retrieveEnergy();break;case 6:this.modules.filling.fillClosest();break;case 7:this.modules.maintenance.fillTowers();break;case 8:this.depositToStorage();break;default:this.getNewTaskForCreep()}}depositToStorage(){2===this.modules.transfer.depositToStorage()&&(this.setTask(2),this.modules.transfer.retrieveEnergy(!0))}getNewTaskForCreep(){if(this.creepIsFull()){this.setTask(6),0!==this.modules.filling.fillClosest()&&this.fillTowersOrStorage()}else this.pickupOrCollect()}fillTowersOrStorage(){if(this._roomState.roomFlags.some(flag=>flag.name.includes("stockpile"))){this.setTask(8),0!==this.modules.transfer.depositToStorage()&&(this.setTask(7),this.modules.maintenance.fillTowers())}else{this.setTask(7),0!==this.modules.maintenance.fillTowers()&&(this.setTask(8),this.modules.transfer.depositToStorage())}}pickupOrCollect(){super.setTask(9),0===this.modules.transfer.pickupDroppedEnergy()||(super.setTask(2),this.modules.transfer.retrieveEnergy())}}class upgrader_creep_controller_UpgraderCreepController extends creep_controller_CreepController{constructor(roomState,creep){super(roomState,creep),this.modules={transfer:new energy_transfer_module_EnergyTransferModule(creep,this),upgrade:new upgrade_module_UpgradeModule(creep,this)}}control(){switch(super.memory.currentTask){case 9:this.modules.transfer.pickupDroppedEnergy();break;case 2:this.modules.transfer.retrieveEnergy();break;case 5:this.modules.upgrade.upgradeController();break;default:this.getNewTaskForCreep()}}getNewTaskForCreep(){super.creepIsFull()?(super.setTask(5),this.modules.upgrade.upgradeController()):(super.setTask(2),this.modules.transfer.retrieveEnergy())}}class repair_module_RepairModule extends CreepControllerModule{repairStructures(){if(void 0===this._controller.memory.currentTaskTargetId)return this.getNewRepairTarget();{const damagedBuilding=this.getTargetStructure(this._controller.memory.currentTaskTargetId);if(void 0===damagedBuilding)this._controller.clearTaskTarget(),this.repairStructures();else{const response=this._creep.repair(damagedBuilding);response===ERR_NOT_IN_RANGE?this._controller.moveTo(damagedBuilding.pos):response===ERR_NOT_ENOUGH_ENERGY&&this._controller.clearTask()}}return 0}getNewRepairTarget(){const closestDamaged=this._controller.findClosest(this._controller._roomState.damagedStructures);return null==closestDamaged?(this._controller.clearTask(),1):(this._controller.memory.currentTaskTargetId=closestDamaged.id,0)}getTargetStructure(structureId){return this._controller._roomState.damagedStructures.find(struct=>struct.id===structureId)}}class builder_creep_controller_BuilderCreepController extends creep_controller_CreepController{constructor(roomState,creep){super(roomState,creep),this.modules={transfer:new energy_transfer_module_EnergyTransferModule(creep,this),build:new build_module_BuildModule(creep,this),repair:new repair_module_RepairModule(creep,this)}}control(){switch(super.memory.currentTask){case 9:this.modules.transfer.pickupDroppedEnergy();break;case 2:this.modules.transfer.retrieveEnergy();break;case 4:this.modules.repair.repairStructures();break;case 3:this.modules.build.buildConstructionSite();break;default:this.getNewTaskForCreep()}}getNewTaskForCreep(){if(super.creepIsFull()){super.setTask(3),0!==this.modules.build.buildConstructionSite()&&(super.setTask(4),this.modules.repair.repairStructures())}else super.setTask(2),this.modules.transfer.retrieveEnergy()}}class TowerController{constructor(tower,roomState){this._tower=tower,this._roomState=roomState}control(){if(null!=this._roomState.enemies&&this._roomState.enemies.length>0)return void this.attackEnemy();this._tower.store.energy/this._tower.store.getCapacity(RESOURCE_ENERGY)>=.5&&this._roomState.damagedStructures.length>0&&this.healStructure()}attackEnemy(){const weakestEnemy=this._roomState.enemies.sort((a,b)=>a.hits-b.hits)[0];this._tower.attack(weakestEnemy)}healStructure(){const mostDamaged=this._roomState.damagedStructures.sort((structA,structB)=>structA.hits-structB.hits)[0];this._tower.repair(mostDamaged)}}const maxCreepCounts={0:{allRounder:2,miner:0,transporter:0,upgrader:0,builder:0,claimer:0,attacker:0},1:{allRounder:0,miner:1,transporter:1,upgrader:1,builder:1,claimer:0,attacker:0},2:{allRounder:0,miner:2,transporter:2,upgrader:1,builder:1,claimer:0,attacker:0}};class spawn_controller_SpawnController{constructor(spawner,roomState){this._spawner=spawner,this._roomState=roomState}spawn(){var _a;let creepType;const allRounders=this._roomState.myCreeps.filter(x=>0===x.memory.currentRole),miners=this._roomState.myCreeps.filter(x=>1===x.memory.currentRole),upgraders=this._roomState.myCreeps.filter(x=>3===x.memory.currentRole),transporters=this._roomState.myCreeps.filter(x=>2===x.memory.currentRole),builders=this._roomState.myCreeps.filter(x=>4===x.memory.currentRole),requiredCreeps=maxCreepCounts[this._roomState.room.memory.currentLevel];if(allRounders.length<requiredCreeps.allRounder?creepType=0:miners.length<requiredCreeps.miner?creepType=1:transporters.length<requiredCreeps.transporter?creepType=2:upgraders.length<requiredCreeps.upgrader?creepType=3:builders.length<requiredCreeps.builder&&(creepType=4),void 0!==creepType){const roomIsMaxedOut=8===(null===(_a=this._roomState.room.controller)||void 0===_a?void 0:_a.level),newCreep=class{static generateCreep(type,room,variant){switch(type){case 2:return this.generateTransporter(room);case 3:return variant?this.generateDelayedUpgrader(room):this.generateUpgrader(room);case 4:return this.generateBuilder(room);case 1:return this.generateMiner(room);default:return this.generateAllRounder()}}static generateAllRounder(){const memory=this.generateMemory(0),name=`MASTER-OF-NONE-${Game.time.toString()}`;return{bodyParts:[WORK,CARRY,CARRY,MOVE],name:name,spawnOptions:{memory:memory}}}static generateTransporter(room){const memory=this.generateMemory(2),name=`STATHAM-${Game.time.toString()}`;return{bodyParts:this.generateMaxLeftoverParts(room.energyAvailable),name:name,spawnOptions:{memory:memory}}}static generateUpgrader(room){const memory=this.generateMemory(3),name=`HARDER-BETTER-FASTER-${Game.time.toString()}`;return{bodyParts:this.generateWorker(room),name:name,spawnOptions:{memory:memory}}}static generateDelayedUpgrader(room){const memory=this.generateMemory(3),name=`HARDER-BETTER-FASTER-${Game.time.toString()}`;return{bodyParts:[...[WORK],...this.generateMaxLeftoverParts(room.energyAvailable-BODYPART_COST[WORK])],name:name,spawnOptions:{memory:memory}}}static generateBuilder(room){const memory=this.generateMemory(4),name=`IM-ON-SMOKO-${Game.time.toString()}`;return{bodyParts:this.generateWorker(room),name:name,spawnOptions:{memory:memory}}}static generateMiner(room){const memory=this.generateMemory(1),name=`ITS-OFF-TO-WORK-I-GO-${Game.time.toString()}`,bodyParts=[WORK,WORK,MOVE,MOVE];let minerCost=bodyParts.map(part=>BODYPART_COST[part]).reduce((prev,current)=>prev+current);for(;room.energyAvailable>=minerCost&&bodyParts.length<7;)bodyParts.push(WORK),minerCost+=BODYPART_COST[WORK];return{bodyParts:bodyParts,name:name,spawnOptions:{memory:memory}}}static generateWorker(room){const workParts=[WORK,CARRY,MOVE],layerCosts=BODYPART_COST[CARRY]+BODYPART_COST[MOVE];let currentBudget=layerCosts,leftoverEnergy=room.energyAvailable-(BODYPART_COST[WORK]+BODYPART_COST[CARRY]+BODYPART_COST[MOVE]),partCount=3;for(;leftoverEnergy>=currentBudget&&partCount<15;)workParts.push(WORK,MOVE),currentBudget+=layerCosts,leftoverEnergy-=BODYPART_COST[WORK]+BODYPART_COST[MOVE],partCount+=2;return[...workParts,...this.generateMaxLeftoverParts(leftoverEnergy,partCount)]}static generateMaxLeftoverParts(energyBudget,partCount=0){const layerCost=BODYPART_COST[MOVE]+BODYPART_COST[CARRY];let energyLeft=energyBudget,bodyParts=[];for(;energyLeft>=100&&partCount<49;)bodyParts=bodyParts.concat([MOVE,CARRY]),energyLeft-=layerCost,partCount+=2;return bodyParts}static generateMemory(currentRole){return{currentRole:currentRole,stuckCounter:0}}}.generateCreep(creepType,this._roomState.room,roomIsMaxedOut);this._spawner.spawnCreep(newCreep.bodyParts,newCreep.name,newCreep.spawnOptions)}}}class room_controller_RoomController{constructor(room){if(this._room=room,null==this._room)throw new Error("Tried to control a room that no longer exists");this._roomFlags=this._room.find(FIND_FLAGS),void 0!==this._room.memory.roomStatus&&void 0!==this._room.memory.currentLevel||(this._room.memory=room_controller_RoomController.createDefaultRoomMemory(room)),this._roomState=new room_memory_manager_RoomMemoryManager(this._room,this._roomFlags)}static createDefaultRoomMemory(room){return{roomStatus:0,currentLevel:0,sourceCount:1,damagedStructureIds:[],droppedEnergyIds:[],enemyIds:[],structureIds:[],myStructureIds:[],constructionSiteIds:[],sourceIds:room.find(FIND_SOURCES).map(source=>source.id)}}runNonCriticalTasks(){var _a;null===(_a=this._roomState)||void 0===_a||_a.calculateNonVolatileRoomState().saveStateToMemory()}runRareTasks(){1===this._room.memory.roomStatus&&(new town_planner_TownPlanner(this._room,this._roomFlags).control(),this._roomState.countRoomSources().calculateRoomLevel())}control(){var _a;this.controlCreeps(),(null===(_a=this._room.controller)||void 0===_a?void 0:_a.my)&&this.controlStructures()}controlCreeps(){const myCreeps=this._roomState.myCreeps,roomExtensions=this._roomState.myStructures.filter(struct=>struct.structureType===STRUCTURE_EXTENSION);myCreeps.forEach(creep=>{let controller;switch(creep.memory.currentRole){case 0:controller=new allrounder_creep_controller_AllRounderCreepController(this._roomState,creep,roomExtensions.length>2);break;case 1:controller=new miner_creep_controller_MinerCreepController(this._roomState,creep);break;case 2:controller=new transporter_creep_controller_TransporterCreepController(this._roomState,creep);break;case 3:controller=new upgrader_creep_controller_UpgraderCreepController(this._roomState,creep);break;case 4:controller=new builder_creep_controller_BuilderCreepController(this._roomState,creep);break;default:console.log("An unsupported creep attempted to be controlled")}null==controller||controller.control()})}controlStructures(){this.controlTowers(),this.controlSpawners()}controlTowers(){const towers=this._roomState.myStructures.filter(struct=>struct.structureType===STRUCTURE_TOWER);if((null==towers?void 0:towers.length)<1)return;const towerCount=towers.length;for(let i=0;i<towerCount;i++)new TowerController(towers[i],this._roomState).control()}controlSpawners(){const spawns=this._roomState.myStructures.filter(struct=>struct.structureType===STRUCTURE_SPAWN);if((null==spawns?void 0:spawns.length)<1)return;const spawnCount=spawns.length;for(let i=0;i<spawnCount;i++)new spawn_controller_SpawnController(spawns[i],this._roomState).spawn()}}function loop(){Game.time%15&&runOccasionalTasks();const isNonCriticalTick=Game.time%5==0,isRareTick=Game.time%30==0;for(let i=0;i<Memory.myMemory.roomIds.length;i++){const myRoomName=Memory.myMemory.roomIds[i],thisController=new room_controller_RoomController(Game.rooms[myRoomName]);thisController.control(),isNonCriticalTick&&thisController.runNonCriticalTasks(),isRareTick&&thisController.runRareTasks()}}function runOccasionalTasks(){MemoryManager.clean(),Memory.myMemory.roomIds=Object.keys(Game.rooms)}__webpack_require__.d(__webpack_exports__,"loop",(function(){return loop})),MemoryManager.initialise(),runOccasionalTasks(),console.log("Script updated: Now running 2.3.0. Built on 17 Mar 2020 22:19")}]);