module.exports=function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=1)}([
/*!***********************************************************!*\
  !*** ./node_modules/screeps-profiler/screeps-profiler.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){"use strict";let usedOnStart=0,enabled=!1,depth=0;function AlreadyWrappedError(){this.name="AlreadyWrappedError",this.message="Error attempted to double wrap a function.",this.stack=(new Error).stack}function setupProfiler(){depth=0,Game.profiler={stream(duration,filter){setupMemory("stream",duration||10,filter)},email(duration,filter){setupMemory("email",duration||100,filter)},profile(duration,filter){setupMemory("profile",duration||100,filter)},background(filter){setupMemory("background",!1,filter)},restart(){if(Profiler.isProfiling()){const filter=Memory.profiler.filter;let duration=!1;Memory.profiler.disableTick&&(duration=Memory.profiler.disableTick-Memory.profiler.enabledTick+1),setupMemory(Memory.profiler.type,duration,filter)}},reset:resetMemory,output:Profiler.output},Game.rooms.sim&&(usedOnStart=0,Game.cpu.getUsed=function(){return performance.now()-usedOnStart})}function setupMemory(profileType,duration,filter){resetMemory();const disableTick=!!Number.isInteger(duration)&&Game.time+duration;Memory.profiler||(Memory.profiler={map:{},totalTime:0,enabledTick:Game.time+1,disableTick:disableTick,type:profileType,filter:filter})}function resetMemory(){Memory.profiler=null}function getFilter(){return Memory.profiler.filter}const functionBlackList=["getUsed","constructor"];function profileObjectFunctions(object,label){const objectToWrap=object.prototype?object.prototype:object;return Object.getOwnPropertyNames(objectToWrap).forEach(functionName=>{const extendedLabel=`${label}.${functionName}`;if(-1!==functionBlackList.indexOf(functionName))return;const descriptor=Object.getOwnPropertyDescriptor(objectToWrap,functionName);if(!descriptor)return;if(descriptor.get||descriptor.set){if(!descriptor.configurable)return;const profileDescriptor={};if(descriptor.get){const extendedLabelGet=`${extendedLabel}:get`;profileDescriptor.get=profileFunction(descriptor.get,extendedLabelGet)}if(descriptor.set){const extendedLabelSet=`${extendedLabel}:set`;profileDescriptor.set=profileFunction(descriptor.set,extendedLabelSet)}return void Object.defineProperty(objectToWrap,functionName,profileDescriptor)}if(!("function"==typeof descriptor.value))return;const originalFunction=objectToWrap[functionName];objectToWrap[functionName]=profileFunction(originalFunction,extendedLabel)}),objectToWrap}function profileFunction(fn,functionName){const fnName=functionName||fn.name;return fnName?function(name,originalFunction){if(originalFunction.profilerWrapped)throw new AlreadyWrappedError;function wrappedFunction(){if(Profiler.isProfiling()){const nameMatchesFilter=name===getFilter(),start=Game.cpu.getUsed();nameMatchesFilter&&depth++;const result=originalFunction.apply(this,arguments);if(depth>0||!getFilter()){const end=Game.cpu.getUsed();Profiler.record(name,end-start)}return nameMatchesFilter&&depth--,result}return originalFunction.apply(this,arguments)}return wrappedFunction.profilerWrapped=!0,wrappedFunction.toString=(()=>`// screeps-profiler wrapped function:\n${originalFunction.toString()}`),wrappedFunction}(fnName,fn):(console.log("Couldn't find a function name for - ",fn),console.log("Will not profile this function."),fn)}const Profiler={printProfile(){console.log(Profiler.output())},emailProfile(){Game.notify(Profiler.output(1e3))},output(passedOutputLengthLimit){const outputLengthLimit=passedOutputLengthLimit||1e3;if(!Memory.profiler||!Memory.profiler.enabledTick)return"Profiler not active.";const elapsedTicks=Math.min(Memory.profiler.disableTick||Game.time,Game.time)-(Memory.profiler.enabledTick+1),header="calls\t\ttime\t\tavg\t\tfunction",footer=[`Avg: ${(Memory.profiler.totalTime/elapsedTicks).toFixed(2)}`,`Total: ${Memory.profiler.totalTime.toFixed(2)}`,`Ticks: ${elapsedTicks}`].join("\t"),lines=[header];let currentLength=header.length+1+footer.length;const allLines=Profiler.lines();let done=!1;for(;!done&&allLines.length;){const line=allLines.shift();currentLength+line.length+1<outputLengthLimit?(lines.push(line),currentLength+=line.length+1):done=!0}return lines.push(footer),lines.join("\n")},lines:()=>Object.keys(Memory.profiler.map).map(functionName=>{const functionCalls=Memory.profiler.map[functionName];return{name:functionName,calls:functionCalls.calls,totalTime:functionCalls.time,averageTime:functionCalls.time/functionCalls.calls}}).sort((val1,val2)=>val2.totalTime-val1.totalTime).map(data=>[data.calls,data.totalTime.toFixed(1),data.averageTime.toFixed(3),data.name].join("\t\t")),prototypes:[{name:"Game",val:Game},{name:"Room",val:Room},{name:"Structure",val:Structure},{name:"Spawn",val:Spawn},{name:"Creep",val:Creep},{name:"RoomPosition",val:RoomPosition},{name:"Source",val:Source},{name:"Flag",val:Flag}],record(functionName,time){Memory.profiler.map[functionName]||(Memory.profiler.map[functionName]={time:0,calls:0}),Memory.profiler.map[functionName].calls++,Memory.profiler.map[functionName].time+=time},endTick(){if(Game.time>=Memory.profiler.enabledTick){const cpuUsed=Game.cpu.getUsed();Memory.profiler.totalTime+=cpuUsed,Profiler.report()}},report(){Profiler.shouldPrint()?Profiler.printProfile():Profiler.shouldEmail()&&Profiler.emailProfile()},isProfiling:()=>!(!enabled||!Memory.profiler)&&(!Memory.profiler.disableTick||Game.time<=Memory.profiler.disableTick),type:()=>Memory.profiler.type,shouldPrint(){const streaming="stream"===Profiler.type(),profiling="profile"===Profiler.type(),onEndingTick=Memory.profiler.disableTick===Game.time;return streaming||profiling&&onEndingTick},shouldEmail:()=>"email"===Profiler.type()&&Memory.profiler.disableTick===Game.time};module.exports={wrap(callback){if(enabled&&setupProfiler(),Profiler.isProfiling()){usedOnStart=Game.cpu.getUsed();const returnVal=callback();return Profiler.endTick(),returnVal}return callback()},enable(){enabled=!0,Profiler.prototypes.forEach(proto=>{profileObjectFunctions(proto.val,proto.name)})},output:Profiler.output,registerObject:profileObjectFunctions,registerFN:profileFunction,registerClass:profileObjectFunctions}},
/*!**************************************!*\
  !*** ./ts-dist/main.js + 20 modules ***!
  \**************************************/
/*! exports provided: loop */
/*! all exports used */function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);class MemoryController{static clean(){this.removeDeadCreeps()}static removeDeadCreeps(){if(null==Memory.creeps)return;const creepIds=Object.keys(Memory.creeps),allCreepsCount=creepIds.length;for(let i=0;i<allCreepsCount;i++){const thisId=creepIds[i];null==Game.creeps[thisId]&&(delete Memory.creeps[thisId],this.removePossibleBuilder(thisId))}}static removePossibleBuilder(id){const index=Memory.myMemory.remoteBuilders.indexOf(id);-1!==index&&Memory.myMemory.remoteBuilders.splice(index,1)}}function filterForEnergy(resource){return resource.amount>=100&&resource.resourceType===RESOURCE_ENERGY}function filterNonEmptyStorage(structure){return(structure.structureType===STRUCTURE_CONTAINER||structure.structureType===STRUCTURE_STORAGE)&&!(structure.store.energy>0)}function filterNonFullStorage(structure){return structure.structureType===STRUCTURE_CONTAINER&&!(structure.store.energy===structure.storeCapacity)}class structure_utils_StructureUtils{static findNonEmptyStorageStructures(structures){return structures.filter(filterNonEmptyStorage)}static findNonFullStorage(structures,creep){const containersAndStorage=structures.filter(filterNonFullStorage),roomStore=creep.room.storage;return null!=roomStore&&containersAndStorage.push(roomStore),containersAndStorage}}class creep_CreepController{constructor(creep,roomState){this.creep=creep,this.roomState=roomState}creepIsFull(){return this.creep.carry.energy===this.creep.carryCapacity}collectEnergy(allowStorage=!1){0!==this.roomState.droppedResources.length?this.collectDroppedEnergy():allowStorage?this.collectEnergyFromStorage():this.mineForResources()}depositEnergyInStorage(){let success,destinationStructure=null;if(null==this.creep.memory.storageTarget){const storageStructures=structure_utils_StructureUtils.findNonFullStorage(this.roomState.structures,this.creep);if(0===storageStructures.length)return!1;let closestStorage=this.creep.pos.findClosestByPath(storageStructures);null==closestStorage&&(closestStorage=storageStructures[0]),this.creep.memory.storageTarget=closestStorage.id,destinationStructure=closestStorage}else destinationStructure=Game.getObjectById(this.creep.memory.storageTarget);return null!=destinationStructure&&(success=this.creep.pos.isNearTo(destinationStructure)?this.creep.transfer(destinationStructure,RESOURCE_ENERGY):this.moveCreepToPos(destinationStructure.pos))===OK}wipeTaskMemory(){this.creep.memory.storageTarget=null,this.creep.memory.miningTarget=null,this.creep.memory.isCollecting=!1,this.creep.memory.isMining=!1}moveCreepToPos(position){const success=this.creep.moveTo(position,{visualizePathStyle:{stroke:"#777a71"},reusePath:15,ignoreCreeps:!1});return success!==OK&&success!==ERR_TIRED&&++this.creep.memory.stuckCounter>=2?(this.creep.say("I'm Stuck"),this.creep.memory.stuckCounter=0,this.creep.moveTo(position,{reusePath:0,ignoreCreeps:!1})):OK}moveCreepToRoomObject(roomObject){return this.moveCreepToPos(roomObject.pos)}getClosestItem(objectList){return this.creep.pos.findClosestByPath(objectList)}collectEnergyFromStorage(){let destinationStructure=null;if(null==this.creep.memory.storageTarget){const storageStructures=this.roomState.nonEmptyStorage;if(0!==storageStructures.length){const closestStorage=this.creep.pos.findClosestByPath(storageStructures);closestStorage?(this.creep.memory.storageTarget=closestStorage.id,destinationStructure=closestStorage):(this.creep.memory.storageTarget=storageStructures[0].id,destinationStructure=storageStructures[0])}}else destinationStructure=Game.getObjectById(this.creep.memory.storageTarget);if(null==destinationStructure)return!1;if(this.creep.pos.isNearTo(destinationStructure.pos)){if(this.creep.withdraw(destinationStructure,RESOURCE_ENERGY)!==OK)return this.wipeTaskMemory(),!1}else this.moveCreepToPos(destinationStructure.pos);return this.creep.memory.isCollecting=!0,!0}collectDroppedEnergy(){const closestDropPoint=this.creep.pos.findClosestByPath(this.roomState.droppedResources);if(null!=closestDropPoint){this.creep.pickup(closestDropPoint)===ERR_NOT_IN_RANGE&&this.moveCreepToRoomObject(closestDropPoint)}}mineForResources(){let miningZone;if(null==this.creep.memory.miningTarget){if(null==(miningZone=this.getClosestSource()))return;this.creep.memory.miningTarget=miningZone.id}else{const currentMiningTarget=Game.getObjectById(this.creep.memory.miningTarget);miningZone=null!=currentMiningTarget?currentMiningTarget:this.getClosestSource()}if(null==miningZone)return;this.creep.harvest(miningZone)===ERR_NOT_IN_RANGE&&this.moveCreepToPos(miningZone.pos),this.creep.memory.isMining=!0}getClosestSource(){const roomSources=this.creep.room.find(FIND_SOURCES);let closestSource=this.creep.pos.findClosestByPath(roomSources);return null==closestSource&&(closestSource=roomSources[0]),closestSource}}const claimFlag="claimMe",priorityRepairFlag="priorityRepair",remoteBuildSiteFlag="remoteBuildSite",maxRemoteBuilderCount=4,maxCreepCounts={builder:2,harvester:2,miner:3,upgrader:2};class builder_BuilderController extends creep_CreepController{constructor(creep,roomState){super(creep,roomState),this.creep=creep}startWork(){if(this.creep.memory.isBuilding&&0===this.creep.carry.energy&&this.startHarvesting(),this.creep.memory.isBuilding||this.creep.carry.energy!==this.creep.carryCapacity||this.startBuilding(),5!==this.creep.memory.role)if(this.creep.memory.isBuilding){this.buildOrTravel()||this.repairOrTravel()}else this.creep.memory.isMining||this.collectEnergy(!0)}wipeTaskMemory(){super.wipeTaskMemory(),this.creep.memory.isBuilding=!1}startBuilding(){this.wipeTaskMemory(),this.checkRemoteBuildStatus()?this.becomeRemoteBuilder():(this.creep.memory.isBuilding=!0,this.creep.memory.isMining=!1,this.creep.memory.isCollecting=!1,this.creep.say("👷 build"))}buildOrTravel(){if(!this.roomState.constructionSites.length)return!1;{const closestSite=this.getClosestItem(this.roomState.constructionSites);if(null==closestSite)return!1;const didBuild=this.creep.build(closestSite);if(didBuild===ERR_NOT_IN_RANGE)this.moveCreepToRoomObject(closestSite);else if(didBuild!==OK)return!1}return!0}startHarvesting(){this.wipeTaskMemory(),this.creep.say("🎒 harvest")}becomeRemoteBuilder(){this.creep.memory.role=5,Memory.myMemory.remoteBuilders.push(this.creep.name),this.creep.say("🗺 Convert")}checkRemoteBuildStatus(){if(null!=Game.flags[remoteBuildSiteFlag]&&null!=Memory.myMemory.remoteBuilders){if(Memory.myMemory.remoteBuilders.length<maxRemoteBuilderCount&&5!==this.creep.memory.role)return!0}return!1}repairOrTravel(){const priorityFlag=Game.flags[priorityRepairFlag];let selectedSite;if(null==(selectedSite=null!=priorityFlag?priorityFlag.pos.findClosestByRange(this.roomState.damagedStructures):this.creep.pos.findClosestByRange(this.roomState.damagedStructures)))return!1;if(this.creep.pos.isNearTo(selectedSite)){return this.creep.repair(selectedSite)===OK}return this.creep.moveTo(selectedSite,{visualizePathStyle:{stroke:"#FFCC00"}}),!0}}class harvester_HarvesterController extends creep_CreepController{constructor(creep,roomState){super(creep,roomState),this.creep=creep}startWork(){0!==this.creep.carry.energy||this.creepMiningOrCollecting()?this.creepIsFull()&&this.creepMiningOrCollecting()?this.switchToDepositing():this.creep.memory.isDepositing?this.depositEnergyOrTravel():this.collectEnergy(!0):this.switchToHarvesting()}switchToHarvesting(){this.wipeTaskMemory(),this.collectEnergy(!0)}switchToDepositing(){this.startDepositing(),this.depositEnergyOrTravel()}creepMiningOrCollecting(){return this.creep.memory.isMining||this.creep.memory.isCollecting}startDepositing(){this.wipeTaskMemory(),this.creep.memory.isDepositing=!0,this.creep.memory.isMining=!1,this.creep.memory.isCollecting=!1,this.creep.say("🚚 deposit")}depositEnergyOrTravel(){const energyStructures=this.roomState.nonFullStructures,closestStructure=this.creep.pos.findClosestByPath(energyStructures);if(null!=closestStructure)if(energyStructures.length>0){if(this.creep.transfer(closestStructure,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE){this.creep.moveTo(closestStructure,{visualizePathStyle:{stroke:"#ffffff"}})===ERR_NO_PATH&&this.transferEnergy(this.creep)}}else this.depositEnergyInStorage()}transferEnergy(creep){const nearbyCreeps=creep.pos.findInRange(FIND_MY_CREEPS,1);if(null!=nearbyCreeps&&nearbyCreeps.length>0){const nearbyCreepCount=nearbyCreeps.length;for(let i=0;i<nearbyCreepCount;i++){const creepi=nearbyCreeps[i];"harvester"===creepi.memory.role&&creepi.carry.energy<creepi.carryCapacity&&creep.transfer(creepi,RESOURCE_ENERGY)}}}}class miner_MinerController extends creep_CreepController{constructor(creep,roomState){super(creep,roomState),this.creep=creep}startWork(){this.creep.memory.isDepositing&&0===this.creep.carry.energy&&this.startHarvesting(),this.creep.memory.isMining&&this.creep.carry.energy===this.creep.carryCapacity&&this.startDepositing(),this.creep.memory.isDepositing?this.depositEnergyInStorage():(this.creep.memory.isMining||this.startHarvesting(),this.collectEnergy())}startHarvesting(){this.creep.memory.isMining=!0,this.creep.memory.isDepositing=!1,this.creep.say("⛏️ harvest")}startDepositing(){this.wipeTaskMemory(),this.creep.memory.isDepositing=!0,this.creep.memory.isMining=!1,this.creep.say("📦 Storing energy")}}const myUserName="james1652",mySignature="Imagine playing a programming game with someone else's code";class upgrader_UpgraderController extends creep_CreepController{constructor(creep,roomState){super(creep,roomState),this.creep=creep}startWork(){this.creep.memory.isUpgrading&&0===this.creep.carry.energy&&this.startHarvesting(),this.creep.memory.isUpgrading||this.creep.carry.energy!==this.creep.carryCapacity||this.startUpgrading(),this.creep.memory.isUpgrading?this.upgradeOrTravel():this.collectEnergy(!0)}startHarvesting(){this.creep.memory.isUpgrading=!1,this.creep.memory.isCollecting=!1,this.creep.memory.isMining=!1,this.creep.say("harvesting")}startUpgrading(){this.wipeTaskMemory(),this.creep.memory.isUpgrading=!0,this.creep.memory.isCollecting=!1,this.creep.memory.isMining=!1,this.creep.say("upgrading")}upgradeOrTravel(){const structureController=this.creep.room.controller;if(null!=structureController){if(this.creep.room.memory.isMyRoom&&!this.creep.room.memory.roomIsSigned)return void this.signControllerOrTravel();this.creep.upgradeController(structureController)===ERR_NOT_IN_RANGE&&this.creep.moveTo(structureController,{visualizePathStyle:{stroke:"#ffffff"}})}}signControllerOrTravel(){null!=this.creep.room.controller&&this.creep.signController(this.creep.room.controller,mySignature)===ERR_NOT_IN_RANGE&&this.moveCreepToRoomObject(this.creep.room.controller)}}class CreepFactory{static generateCreep(type,room){switch(type){case 1:return this.generateUpgrader(room);case 2:return this.generateBuilder(room);case 3:return this.generateMiner(room);case 4:return this.generateClaimer();default:return this.generateHarvester(room)}}static generateClaimer(){const memory=this.generateMemory(4),name=`CLMR-${Game.time.toString()}`;return{bodyParts:[MOVE,CLAIM],name:name,spawnOptions:{memory:memory}}}static generateHarvester(room){const memory=this.generateMemory(0),name=`HRVSTR-${Game.time.toString()}`;return{bodyParts:this.generateMaxWorkerBodyParts(room),name:name,spawnOptions:{memory:memory}}}static generateUpgrader(room){const memory=this.generateMemory(1),name=`UPGRDR-${Game.time.toString()}`;return{bodyParts:this.generateMaxWorkerBodyParts(room),name:name,spawnOptions:{memory:memory}}}static generateBuilder(room){const memory=this.generateMemory(2),name=`BLDR-${Game.time.toString()}`;return{bodyParts:this.generateMaxWorkerBodyParts(room),name:name,spawnOptions:{memory:memory}}}static generateMiner(room){const memory=this.generateMemory(3),name=`MNR-${Game.time.toString()}`;return{bodyParts:this.generateMaxWorkerBodyParts(room),name:name,spawnOptions:{memory:memory}}}static generateMaxWorkerBodyParts(currentRoom){let energyLeft=currentRoom.energyAvailable,bodyParts=[];for(;energyLeft>=250;)bodyParts=bodyParts.concat([WORK,MOVE,CARRY,MOVE]),energyLeft-=250;return bodyParts}static generateMemory(role){return{role:role,stuckCounter:0}}}class spawn_SpawnController{static spawn(spawner,roomState,room){this.spawnCreeps(spawner,roomState.slaves,maxCreepCounts,room)}static spawnCreeps(spawner,creeps,counts,room){let creepType=6;const upgraders=creeps.filter(x=>1===x.memory.role),harvesters=creeps.filter(x=>0===x.memory.role),builders=creeps.filter(x=>2===x.memory.role),miners=creeps.filter(x=>3===x.memory.role);if(harvesters.length<counts.harvester?creepType=0:upgraders.length<counts.upgrader?creepType=1:builders.length<counts.builder?creepType=2:miners.length<counts.miner?creepType=3:null==Game.flags.claimMe||Memory.myMemory.claimerPresent||this.spawnClaimer(spawner,room),6!==creepType){const newCreep=CreepFactory.generateCreep(creepType,room);spawner.spawnCreep(newCreep.bodyParts,newCreep.name,newCreep.spawnOptions)}}static spawnClaimer(spawner,room){const newClaimer=CreepFactory.generateCreep(4,room);spawner.spawnCreep(newClaimer.bodyParts,newClaimer.name,newClaimer.spawnOptions)===OK&&(Memory.myMemory.claimerPresent=!0)}}class TowerController{constructor(tower,roomState){this.tower=tower,this.roomState=roomState}command(){null!=this.roomState.enemies&&this.roomState.enemies.length>0?this.attackEnemy():this.tower.energy/this.tower.energyCapacity>=.5&&null!=this.roomState.damagedStructures&&this.roomState.damagedStructures.length>1&&this.healStructure()}attackEnemy(){const weakestEnemy=this.roomState.enemies[0];this.tower.attack(weakestEnemy)}healStructure(){const mostDamaged=this.roomState.damagedStructures[0];this.tower.repair(mostDamaged)}}function isHarvester(creep){const thisCreep=creep;return 0===thisCreep.memory.role||"harvester"===thisCreep.memory.role}function isUpgrader(creep){const thisCreep=creep;return 1===thisCreep.memory.role||"upgrader"===thisCreep.memory.role}function isBuilder(creep){const thisCreep=creep;return 2===thisCreep.memory.role||"builder"===thisCreep.memory.role}function isRemoteBuilder(creep){const thisCreep=creep;return 5===thisCreep.memory.role||"remoteBuilder"===thisCreep.memory.role}function isMiner(creep){const thisCreep=creep;return 3===thisCreep.memory.role||"miner"===thisCreep.memory.role}function isClaimer(creep){const thisCreep=creep;return 4===thisCreep.memory.role||"claimer"===thisCreep.memory.role}class claimer_ClaimerController extends creep_CreepController{constructor(creep,roomState,flag){super(creep,roomState),this.creep=creep,this.claimFlag=flag}startWork(){this.creep.memory.isTravelling||this.creep.memory.isInCorrectRoom?this.creep.memory.isInCorrectRoom?this.isInFlagRoom()&&!this.creep.room.memory.isMyRoom?this.claimController():this.isInFlagRoom()&&this.creep.room.memory.isMyRoom?(this.replaceFlag(),Memory.myMemory.claimerPresent=!1,this.convertToBuilder()):console.log("Claimer creep attempted to perform unsupported behaviour"):this.isInFlagRoom()?this.stopTravelling():this.travelAcrossRooms():this.startTravelling()}replaceFlag(){this.claimFlag.remove(),this.creep.pos.createFlag(remoteBuildSiteFlag,COLOR_YELLOW)}startTravelling(){this.creep.say("🗺 Travel"),this.creep.memory.isTravelling=!0,this.creep.memory.isInCorrectRoom=!1}stopTravelling(){this.creep.say("🧠 Claiming"),this.creep.memory.isTravelling=!1,this.creep.memory.isInCorrectRoom=!0}travelAcrossRooms(){this.moveCreepToPos(this.claimFlag.pos)}claimController(){const thisController=this.creep.room.controller;this.creep.pos.isNearTo(thisController)?(this.creep.say("🧠 Claiming"),this.creep.claimController(thisController)):(this.creep.say("🗺 Travel"),this.moveCreepToPos(thisController.pos))}convertToBuilder(){delete this.creep.memory.isInCorrectRoom,delete this.creep.memory.isTravelling,this.creep.say(" Switching"),this.creep.memory.role="builder"}isInFlagRoom(){return null==this.claimFlag||this.creep.pos.roomName===this.claimFlag.pos.roomName}}const allyUsernames=["Smudgemuffin","mooseyman"];class remote_builder_RemoteBuilderController extends builder_BuilderController{constructor(creep,roomState){super(creep,roomState),this.remoteBuildFlag=Game.flags[remoteBuildSiteFlag]}startWork(){null==this.remoteBuildFlag&&this.convertToHarvester();const isInRoom=this.creep.pos.roomName===this.remoteBuildFlag.pos.roomName,isNextToFlag=this.creep.pos.inRangeTo(this.remoteBuildFlag.pos,1);if(isInRoom&&isNextToFlag){this.convertToRegularBuilder(),this.creep.room.find(FIND_MY_SPAWNS)&&this.remoteBuildFlag.remove()}else this.creep.say("🗺 Travel"),this.moveCreepToRoomObject(this.remoteBuildFlag)}convertToHarvester(){delete this.creep.memory.isBuilding,this.creep.say(" Switching"),this.creep.memory.role=0}convertToRegularBuilder(){this.creep.memory.role=2,this.wipeTaskMemory()}}class RoomState{constructor(storedState){this.damagedStructures=[],this.enemies=[],this.structures=[],this.myStructures=[],this.constructionSites=[],this.droppedResources=[],this.slaves=[],this.nonFullStructures=[],this.nonEmptyStorage=[],null!=storedState&&(this.damagedStructures=storedState.damagedStructureIds.map(id=>Game.getObjectById(id)).filter(structure=>null!=structure),this.enemies=storedState.enemyIds.map(id=>Game.getObjectById(id)).filter(enemy=>null!=enemy),this.structures=storedState.structureIds.map(id=>Game.getObjectById(id)).filter(structure=>null!=structure),this.myStructures=storedState.myStructureIds.map(id=>Game.getObjectById(id)).filter(structure=>null!=structure),this.constructionSites=storedState.constructionSiteIds.map(id=>Game.getObjectById(id)),this.droppedResources=storedState.droppedEnergyIds.map(id=>Game.getObjectById(id)))}}class room_controller_RoomController{constructor(room){this.room=room,null==this.room.memory.isMyRoom&&(this.room.memory=room_controller_RoomController.createDefaultRoomMemory()),this.room.memory.isMyRoom?this.roomState=this.calculateCurrentRoomState():this.roomState=this.getForeignRoomState()}static createDefaultRoomMemory(){return{isMyRoom:!1,roomIsSigned:!1,damagedStructureIds:[],enemyIds:[],structureIds:[],myStructureIds:[],constructionSiteIds:[],droppedEnergyIds:[]}}control(){this.room.memory.isMyRoom&&this.commandStructures(),this.commandCreeps()}commandStructures(){const justTowers=this.roomState.structures.filter(s=>s.structureType===STRUCTURE_TOWER),justSpawners=this.roomState.structures.filter(s=>s.structureType===STRUCTURE_SPAWN);this.commandTowers(justTowers),this.commandSpawners(justSpawners)}commandTowers(towers){if(null==towers||0===towers.length)return;const towerCount=towers.length;for(let i=0;i<towerCount;i++){new TowerController(towers[i],this.roomState).command()}}commandSpawners(spawns){if(null==spawns||0===spawns.length)return;const spawnCount=spawns.length;for(let i=0;i<spawnCount;i++)spawn_SpawnController.spawn(spawns[i],this.roomState,this.room)}calculateNonVolatileRoomState(){const allStructures=this.room.find(FIND_STRUCTURES),myStructures=this.room.find(FIND_MY_STRUCTURES),constructionSites=this.room.find(FIND_CONSTRUCTION_SITES),droppedEnergy=this.room.find(FIND_DROPPED_RESOURCES).filter(filterForEnergy),enemies=this.room.find(FIND_HOSTILE_CREEPS).filter(creep=>-1===allyUsernames.indexOf(creep.owner.username)).sort((a,b)=>a.hits-b.hits);let isRoomSigned=!1;null!=this.room.controller&&(isRoomSigned=null!=this.room.controller.sign&&this.room.controller.sign.username==myUserName);const damagedStructures=allStructures.filter(x=>x.hits<x.hitsMax).sort((a,b)=>a.hits-b.hits);this.room.memory.isMyRoom=null!=this.room.controller&&this.room.controller.my,this.room.memory.roomIsSigned=isRoomSigned,this.room.memory.damagedStructureIds=damagedStructures.map(x=>x.id),this.room.memory.enemyIds=enemies.map(x=>x.id),this.room.memory.structureIds=allStructures.map(x=>x.id),this.room.memory.myStructureIds=myStructures.map(x=>x.id),this.room.memory.constructionSiteIds=constructionSites.map(site=>site.id),this.room.memory.droppedEnergyIds=droppedEnergy.map(resource=>resource.id);const newState=new RoomState;return newState.damagedStructures=damagedStructures,newState.enemies=enemies,newState.structures=allStructures,newState.myStructures=myStructures,newState.constructionSites=constructionSites,newState}calculateCurrentRoomState(){let roomState;roomState=Game.time%10?this.calculateNonVolatileRoomState():new RoomState(this.room.memory);const slaves=this.room.find(FIND_MY_CREEPS),nonFullStructures=roomState.structures.filter(structure=>structure.structureType===STRUCTURE_EXTENSION||structure.structureType===STRUCTURE_SPAWN||structure.structureType===STRUCTURE_TOWER&&structure.energy<structure.energyCapacity),nonEmptyStorage=structure_utils_StructureUtils.findNonEmptyStorageStructures(roomState.structures);return roomState.slaves=slaves,roomState.nonFullStructures=nonFullStructures,roomState.nonEmptyStorage=nonEmptyStorage,roomState}getForeignRoomState(){const roomState=new RoomState;Game.time%10&&(this.room.memory.isMyRoom=null!=this.room.controller&&this.room.controller.my);const slaves=this.room.find(FIND_MY_CREEPS),allStructures=this.room.find(FIND_STRUCTURES),myStructures=this.room.find(FIND_MY_STRUCTURES),constructionSites=this.room.find(FIND_CONSTRUCTION_SITES);return roomState.slaves=slaves,roomState.structures=allStructures,roomState.myStructures=myStructures,roomState.constructionSites=constructionSites,roomState}commandCreeps(){const creepCount=this.roomState.slaves.length;for(let i=0;i<creepCount;i++){const thisCreep=this.roomState.slaves[i];let controller;isHarvester(thisCreep)?controller=new harvester_HarvesterController(thisCreep,this.roomState):isUpgrader(thisCreep)?controller=new upgrader_UpgraderController(thisCreep,this.roomState):isBuilder(thisCreep)?controller=new builder_BuilderController(thisCreep,this.roomState):isMiner(thisCreep)?controller=new miner_MinerController(thisCreep,this.roomState):isClaimer(thisCreep)?controller=new claimer_ClaimerController(thisCreep,this.roomState,Game.flags[claimFlag]):isRemoteBuilder(thisCreep)?controller=new remote_builder_RemoteBuilderController(thisCreep,this.roomState):(console.log("Attempted to control an unsupported creep. Falling back to Harvester"),console.log(`Name: ${thisCreep.name} Role: ${thisCreep.memory.role}`),controller=new harvester_HarvesterController(thisCreep,this.roomState)),controller.startWork()}}}__webpack_require__.d(__webpack_exports__,"loop",function(){return loop});const profiler=__webpack_require__(/*! screeps-profiler */0);function loop(){profiler.wrap(function(){Game.time%15&&runOccasionalTasks();for(let i=0;i<Memory.myMemory.roomNames.length;i++){const myRoomName=Memory.myMemory.roomNames[i];new room_controller_RoomController(Game.rooms[myRoomName]).control()}})}function runOccasionalTasks(){MemoryController.clean(),Memory.myMemory.roomNames=Object.keys(Game.rooms)}!function(){null==Memory.myMemory&&(Memory.myMemory={roomNames:[],remoteBuilders:[],claimerPresent:!1});runOccasionalTasks(),console.log("Script updated: Now running 1.8.0")}(),profiler.enable()}]);