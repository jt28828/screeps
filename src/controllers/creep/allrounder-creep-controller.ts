import { RoomMemoryManager } from "../../memory/room-memory-manager";
import { IController } from "../../models/interfaces/controller";
import { CreepTasks } from "../../enums/creep-tasks";
import { CreepController } from "./base/creep-controller";
import { MinerModule } from "./modules/miner-module";
import { EnergyTransferModule } from "./modules/energy-transfer-module";

/** Controls the allrounder creep, the creep generated by the room only at lower levels */
export class AllRounderCreepController extends CreepController<AllRounderCreep> implements IController {
    protected modules: { mine: MinerModule, transfer: EnergyTransferModule };


    constructor(roomState: RoomMemoryManager, creep: AllRounderCreep) {
        super(roomState, creep);
        this.modules = {
            mine: new MinerModule(creep, this),
            transfer: new EnergyTransferModule(creep, this)
        }
    }

    /**
     * Orders the allrounder creep to perform actions in this order of importance:
     * Build Structures, Upgrade, Collect Energy, Mine Energy
     */
    public control() {
        if (this.memory.currentTask === CreepTasks.building) {
            // Continue building / travelling to build site
            this.buildConstructionSite();
        } else if (this.memory.currentTask === CreepTasks.upgrading) {
            // Continue upgrading / travelling to controller
        }

        if (this.creepIsFull()) {
            // Deposit energy in the closest storage
            this.depositEnergy()
        } else {
            // Mine for more energy
            this.mineForEnergy();
        }
    }

    /** Builds the closest construction site */
    private buildConstructionSite() {
        if (this.memory.currentTaskTargetId !== undefined) {
            // Creep has a target.
            const constructionSite = this.getTargetConstructionSite(this.memory.currentTaskTargetId);
            if (constructionSite === undefined) {
                // Construction site doesn't exist, wipe from memory and start again
                this.clearTaskTarget();
                this.buildConstructionSite();
            } else {
                const response = this._creep.build(constructionSite);

                if (response === ERR_NOT_IN_RANGE) {
                    // Not close enough, move to the construction site
                    this.moveTo(constructionSite.pos);
                }
            }
        } else {
            this.getNewConstructionSite();
        }
    }

    /** Gets a new construction target for the current creep */
    private getNewConstructionSite() {
        const closestSite = this.findClosest(this._roomState.constructionSites);

        if (closestSite != null) {
            this.memory.currentTaskTargetId = closestSite.id;
        }
    }

    /** Retrieves the construction site a creep has chosen to build */
    private getTargetConstructionSite(siteId: string) {
        return this._roomState.constructionSites.get(siteId);
    }
}
